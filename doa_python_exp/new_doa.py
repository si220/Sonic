# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13-h7Gq5BB7nPt47Ovhwvcvalt6MayPK3
"""

import pyaudio
import wave
import numpy as np

file_0 = wave.open("output_0.wav")
file_1 = wave.open("output_1.wav")
file_2 = wave.open("output_2.wav")
file_3 = wave.open("output_3.wav")
file_4 = wave.open("output_4.wav")
file_5 = wave.open("output_5.wav")

samples = file_0.getnframes()
audio = file_0.readframes(samples)
audio_as_np_int16 = np.frombuffer(audio, dtype=np.int16)
audio_as_np_float32 = audio_as_np_int16.astype(np.float32)
max_int16 = 2**15
frames_0 = audio_as_np_float32 / max_int16

samples = file_1.getnframes()
audio = file_1.readframes(samples)
audio_as_np_int16 = np.frombuffer(audio, dtype=np.int16)
audio_as_np_float32 = audio_as_np_int16.astype(np.float32)
max_int16 = 2**15
frames_1 = audio_as_np_float32 / max_int16

samples = file_2.getnframes()
audio = file_2.readframes(samples)
audio_as_np_int16 = np.frombuffer(audio, dtype=np.int16)
audio_as_np_float32 = audio_as_np_int16.astype(np.float32)
max_int16 = 2**15
frames_2 = audio_as_np_float32 / max_int16

samples = file_3.getnframes()
audio = file_3.readframes(samples)
audio_as_np_int16 = np.frombuffer(audio, dtype=np.int16)
audio_as_np_float32 = audio_as_np_int16.astype(np.float32)
max_int16 = 2**15
frames_3 = audio_as_np_float32 / max_int16

samples = file_4.getnframes()
audio = file_4.readframes(samples)
audio_as_np_int16 = np.frombuffer(audio, dtype=np.int16)
audio_as_np_float32 = audio_as_np_int16.astype(np.float32)
max_int16 = 2**15
frames_4 = audio_as_np_float32 / max_int16

samples = file_5.getnframes()
audio = file_5.readframes(samples)
audio_as_np_int16 = np.frombuffer(audio, dtype=np.int16)
audio_as_np_float32 = audio_as_np_int16.astype(np.float32)
max_int16 = 2**15
frames_5 = audio_as_np_float32 / max_int16

file_0.close()
file_1.close()
file_2.close()
file_3.close()
file_4.close()
file_5.close()

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt

def peak_sample_signal(sig, filter_order=4, cutoff_frequency=1000):

  n_samples = len(sig)  # Number of samples

  # Design a high-pass Butterworth filter
  order = filter_order  # Filter order
  cutoff_freq = cutoff_frequency  # Cutoff frequency of the filter (in Hz)
  nyquist_freq = 0.5 * n_samples  # Nyquist frequency
  normal_cutoff = cutoff_freq / nyquist_freq
  b, a = butter(order, normal_cutoff, btype='high', analog=False)

  # Apply the filter to the noisy signal
  recovered_signal = filtfilt(b, a, sig)

  recovered_signal[np.abs(recovered_signal)<np.max(np.abs(recovered_signal))/10]=0

  return recovered_signal

from scipy.signal import correlate

def phase_transform(signal1, signal2):
    # Compute the cross-correlation using scipy's correlate function
    cross_correlation = correlate(signal1, signal2, mode='full')

    # Compute the Fourier transform of the cross-correlation
    fft_cross_correlation = np.fft.rfft(cross_correlation)

    # Compute the magnitude spectrum
    magnitude_spectrum = np.abs(fft_cross_correlation)

    # Compute the phase spectrum
    phase_spectrum = np.angle(fft_cross_correlation)

    return phase_spectrum

import matplotlib.pyplot as plt

def compute_error(signal1, signal2):
    # Compute the mean squared error (MSE)
    error = np.mean((signal1 - signal2) ** 2)

    return error

def estimate_delay_phase(sig1, sig2, fs=16000, cutoff_freq=1000):

  sig_1 = denoise_sample_signal(sig1, cutoff_frequency=cutoff_freq)
  sig_2 = denoise_sample_signal(sig2, cutoff_frequency=cutoff_freq)

  #plt.plot(sig_1, label='sig 1')
  #plt.plot(sig_2, label='sig 2')
  #plt.title('original')
  #plt.grid(True)
  #plt.show()

  peak_index = np.argmax(phase_transform(sig_1, sig_2))
  if peak_index>int(len(sig_1)/2):
    print('length: '+str(int(len(sig_1)/2)))
    peak_index = int(len(sig_1)/2)-peak_index
    print(peak_index)

  print('shift: '+str(peak_index))
  time_delay = peak_index/fs
  print('delay is: '+str(time_delay)+'s')

  shifted_signal = np.roll(sig_2, peak_index)

  #plt.plot(sig_1, label='sig 1')
  #plt.plot(shifted_signal, label='sig 2')
  #plt.title('aligned')
  #plt.grid(True)
  #plt.show()

  # Compute the error between the two signals
  mse_error = compute_error(sig_1, shifted_signal)
  old_mse_error = compute_error(sig_1, sig_2)

  # Print the result
  #print("Mean Squared Error (MSE) between signal1 and signal2 before alignment:", old_mse_error)
  #print("Mean Squared Error (MSE) between signal1 and signal2 after alignment:", mse_error)

  return peak_index, time_delay

def l0_norm_error(vector1, vector2):
    return np.sum((vector1 != 0) != (vector2 != 0))

def estimate_delay_search(sig1, sig2, max_delay_samples=5, fs=16000):
  sig_1 = peak_sample_signal(sig1, cutoff_frequency=cutoff_freq)
  sig_2 = peak_sample_signal(sig2, cutoff_frequency=cutoff_freq)

  #plt.plot(sig_1, label='sig 1')
  #plt.plot(sig_2, label='sig 2')
  #plt.title('original')
  #plt.grid(True)
  #plt.show()

  old_error = l0_norm_error(sig_1, sig_2)
  shift = 0

  for i in range(-max_delay_samples, max_delay_samples+1):
    tmp_signal = np.roll(sig_2, i)
    new_error = l0_norm_error(sig_1, tmp_signal)
    if new_error<old_error:
      shift=i
      old_error=new_error

  shifted_signal = np.roll(sig_2, shift)

  #plt.plot(sig_1, label='sig 1')
  #plt.plot(shifted_signal, label='sig 2')
  #plt.title('aligned')
  #plt.grid(True)
  #plt.show()

  #print("Error between signal1 and signal2 before alignment:", l0_norm_error(sig_1, sig_2))
  #print("Error between signal1 and signal2 after alignment:", l0_norm_error(sig_1, shifted_signal))

  time_delay = shift/fs

  return shift, time_delay

ind, delta = estimate_delay_search(frames_3, frames_2)

print("time delay:", delta, "s")

def DOA(mic_distance, sig_1, sig_2, sig_3, sig_4, sig_5, sig_6):
  r=mic_distance
  # x y coordinates
  mic1_coord = np.array([r*np.cos(0*np.pi/180), r*np.sin(0*np.pi/180)])
  mic2_coord = np.array([r*np.cos(60*np.pi/180), r*np.sin(60*np.pi/180)])
  #mic3_coord = np.array([r*np.cos(120*np.pi/180), r*np.sin(120*np.pi/180)])
  mic4_coord = np.array([r*np.cos(180*np.pi/180), r*np.sin(180*np.pi/180)])
  #mic5_coord = np.array([r*np.cos(240*np.pi/180), r*np.sin(240*np.pi/180)])
  mic6_coord = np.array([r*np.cos(300*np.pi/180), r*np.sin(300*np.pi/180)])

  _, delta12 = estimate_delay_search(sig_1, sig_2)
  _, delta54 = estimate_delay_search(sig_5, sig_4)
  _, delta63 = estimate_delay_search(sig_6, sig_3)
  _, delta16 = estimate_delay_search(sig_1, sig_6)
  _, delta25 = estimate_delay_search(sig_2, sig_5)
  _, delta34 = estimate_delay_search(sig_3, sig_4)
  _, delta14 = estimate_delay_search(sig_1, sig_4)
  _, delta23 = estimate_delay_search(sig_2, sig_3)
  _, delta65 = estimate_delay_search(sig_6, sig_5)

  direction_vector = -(delta12+delta54+delta63)*(mic2_coord-mic1_coord)+(delta16+delta25+delta34)*(mic6_coord-mic1_coord)-(delta14+delta23+delta65)*(mic4_coord-mic1_coord)

  angle = np.arctan(direction_vector[1]/direction_vector[0])*180/np.pi

  if angle<0:
    angle+=360

  return angle

DOA(MIC_DISTANCE_6, frames_0, frames_1, frames_2, frames_3, frames_4, frames_5)